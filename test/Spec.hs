{-# LANGUAGE NegativeLiterals #-}

-- | In this file, you do not need to implement anything, but it would be useful
-- to read through these functions---you do not need to understand all the
-- details.

import Prelude hiding (replicate)
import Lists

-- | In this file, we use a famous Haskell testing tool, QuickCheck. Instead of
-- writing test cases, you write down specifications, or the properties that you
-- would like your implementation to have. The tool will then automatically
-- generates test cases and check if these properties are satisfied by your
-- implememtation. If not, a minimal counterexample can also be provided by
-- QuickCheck---if your implementation is flawless, you might want to manually
-- introduce a few bugs just to see how QuickCheck works when your code is
-- wrong. Remember to get rid of these bugs before submitting your assignment!

import Test.QuickCheck

-- | This function instructs QuickCheck to check all the properties we specified
-- below.

main :: IO ()
main = do
  print "testing grid..."
  quickCheck propGridElem
  print "testing square..."
  quickCheck propSquareElem
  quickCheck propSquareDiag
  print "testing replicate..."
  quickCheck propReplicateLength
  quickCheck propReplicateId
  print "testing pyths..."
  quickCheck propPyths
  quickCheck propPythsEmpty
  quickCheck propPythsComplete

-- | This function checks if a coordinate is part of the coordinate grid
-- generated by the 'grid' function. In the case of failure, you will find a
-- minimized counterexample of four non-negative numbers that falsify your
-- implementation. The first two numbers are a coordinate that should or should
-- not belong to the coordinate grid, and the last two numbers are the
-- parameters passed to the 'grid' function.
propGridElem :: NonNegative Int ->
                NonNegative Int ->
                NonNegative Int ->
                NonNegative Int ->
                Bool
propGridElem (NonNegative x1) (NonNegative x2)
             (NonNegative y1) (NonNegative y2)
  | x1 <= x2 && y1 <= y2 = elem (x1, y1) (grid x2 y2)
  | otherwise            = not (elem (x1, y1) (grid x2 y2))

-- | The function is largely similar to the one above.
propSquareElem :: NonNegative Int ->
                  NonNegative Int ->
                  NonNegative Int ->
                  Bool
propSquareElem (NonNegative x) (NonNegative y) (NonNegative n)
  | x <= n && y <= n && x /= y = elem (x, y) (square n)
  | otherwise                  = not (elem (x, y) (square n))

-- | The function checks if diagonals are excluded.
propSquareDiag :: NonNegative Int -> NonNegative Int -> Bool
propSquareDiag (NonNegative x) (NonNegative n) =
  not (elem (x, x) (square n))

-- | The function checks if the length of the list produced by 'replicate' is
-- correct.
propReplicateLength :: Int -> Int -> Bool
propReplicateLength n a | n >= 0    = length (replicate n a) == n
                        | otherwise = length (replicate n a) == 0

-- | The function checks if an arbitrary element in the list produced by
-- 'replicate' equals to the argument passed to 'replicate'.
propReplicateId :: Positive Int -> Int -> Gen Bool
propReplicateId (Positive n) a = do
  i <- elements (replicate n a)
  return (i == a)

-- | The functions checks if an arbitrary element in the list produced by
-- 'pyths' satisfies the relation that x^2 + y^2 = z^2. In addition, it also
-- checks if all the numbers are positive and z <= n.
propPyths :: Property
propPyths =
  forAllShrink (choose (5, 12)) (\n -> [5..n-1])
  (\n -> do
     (x, y, z) <- elements (pyths n)
     return (x^2 + y^2 == z^2 &&
             z <= n && x > 0 && y > 0 && z > 0))

-- | The function checks if the parameter passed to 'pyths' is less than 5
-- (could be negative), the function produces an empty list.
propPythsEmpty :: Property
propPythsEmpty =
  forAllShrink (choose (-1000, 4)) (\n -> [n+1..4])
  (\n -> length (pyths n) == 0)

-- | The function uses a different strategy to generate Pythagorean triples and
-- checks if a triple generated in this way can be found in a list produced by
-- 'pyths'.
propPythsComplete :: Property
propPythsComplete =
  forAllShrink (choose (2, 12)) (\n -> [2..n-1])
  (\m -> do
      n <- choose (1, m-1)
      let x = m^2 - n^2
      let y = 2 * m * n
      let z = m^2 + n^2
      return $ elem (x, y, z) (pyths z))

-- | We do not have functions for checking 'perfects' or 'scalarProduct'.
